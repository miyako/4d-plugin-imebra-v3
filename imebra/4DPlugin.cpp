/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Imebra
 #	author : miyako
 #	2016/12/06
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"


void PluginMain(PA_long32 selector, PA_PluginParameters params){
    
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

        switch(pProcNum)
        {
                // --- Imebra
                
            case 1 :
                Imebra_Get_images(params);
                break;

            case 2 :
                Imebra_Apply_filters(params);
                break;

            default :
                CommandDispatcher(pProcNum, pResult, pParams);
                break;
        }

	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams){
    
	switch(pProcNum)
	{
// --- Imebra
	}
}

// ------------------------------------ Imebra ------------------------------------

void json_wconv(const wchar_t *value, CUTF16String *u16){
    
    size_t wlen = wcslen(value);
    
#if VERSIONWIN
    *u16 = CUTF16String((const PA_Unichar *)value, wlen);
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)value, wlen*sizeof(wchar_t), kCFStringEncodingUTF32LE, true);
    if(str)
    {
        int len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        *u16 = CUTF16String((const PA_Unichar *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

void ob_set_p(PA_ObjectRef obj, const wchar_t *_key, PA_Picture value){
    
    if(obj)
    {
        if(value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Picture);
            CUTF16String ukey;
            json_wconv(_key, &ukey);
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            
            PA_SetPictureVariable(&v, value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_s(PA_ObjectRef obj, const wchar_t *_key, const char *_value){
    
    if(obj)
    {
        if(_value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            CUTF16String ukey;
            
            json_wconv(_key, &ukey);
            
            CUTF8String u8 = CUTF8String((const uint8_t *)_value);
            C_TEXT t;t.setUTF8String(&u8);
            
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            PA_Unistring value = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
            
            PA_SetStringVariable(&v, &value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_a(PA_ObjectRef obj, const wchar_t *_key, const wchar_t *_value){
    
    if(obj)
    {
        if(_value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            CUTF16String ukey;
            CUTF16String uvalue;
            json_wconv(_key, &ukey);
            json_wconv(_value, &uvalue);
            
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            PA_Unistring value = PA_CreateUnistring((PA_Unichar *)uvalue.c_str());
            
            PA_SetStringVariable(&v, &value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_c(PA_ObjectRef obj, const wchar_t *_key, PA_CollectionRef value){
    
    if(obj)
    {
        if(value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Collection);
            CUTF16String ukey;
            json_wconv(_key, &ukey);
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            
            PA_SetCollectionVariable(&v, value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_i(PA_ObjectRef obj, const wchar_t *_key, PA_long32 value){
    
    if(obj)
    {
        PA_Variable v = PA_CreateVariable(eVK_Longint);
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        PA_SetLongintVariable(&v, value);
        PA_SetObjectProperty(obj, &key, v);
        
        PA_DisposeUnistring(&key);
        PA_ClearVariable(&v);
    }
}

void ob_set_b(PA_ObjectRef obj, const wchar_t *_key, bool value){
    
    if(obj)
    {
        PA_Variable v = PA_CreateVariable(eVK_Boolean);
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        PA_SetBooleanVariable(&v, value);
        PA_SetObjectProperty(obj, &key, v);
        
        PA_DisposeUnistring(&key);
        PA_ClearVariable(&v);
    }
}

bool ob_is_defined(PA_ObjectRef obj, const wchar_t *_key){
    
    bool is_defined = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        is_defined = PA_HasObjectProperty(obj, &key);
        
        PA_DisposeUnistring(&key);
    }
    return is_defined;
}

bool ob_get_a(PA_ObjectRef obj, const wchar_t *_key, CUTF8String *value){
    
    bool is_defined = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        is_defined = PA_HasObjectProperty(obj, &key);
        
        if(is_defined)
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Unistring)
            {
                PA_Unistring uvalue = PA_GetStringVariable(v);
                C_TEXT t;
                t.setUTF16String(&uvalue);
                t.copyUTF8String(value);
            }
        }

        PA_DisposeUnistring(&key);
    }
    
    return is_defined;
}

bool ob_get_b(PA_ObjectRef obj, const wchar_t *_key){
    
    bool value = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        if(PA_HasObjectProperty(obj, &key))
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Boolean)
            {
                value = PA_GetBooleanVariable(v);
            }
        }
        
        PA_DisposeUnistring(&key);
    }
    
    return value;
}

double ob_get_n(PA_ObjectRef obj, const wchar_t *_key){
    
    double value = 0.0f;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        if(PA_HasObjectProperty(obj, &key))
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Real)
            {
                value = PA_GetRealVariable(v);
            }
        }
        
        PA_DisposeUnistring(&key);
    }
    
    return value;
}

PA_CollectionRef ob_get_c(PA_ObjectRef obj, const wchar_t *_key){
    
    PA_CollectionRef value = NULL;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        if(PA_HasObjectProperty(obj, &key))
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Collection)
            {
                value = PA_GetCollectionVariable(v);
            }
        }
        
        PA_DisposeUnistring(&key);
    }
    return value;
}

#pragma mark -

void Imebra_Get_images(PA_PluginParameters params){
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    PA_Handle h = PA_GetBlobHandleParameter( params, 1 );
    PA_ObjectRef options = PA_GetObjectParameter( params, 2 );
    
    PA_CollectionRef colTags = NULL;
    PA_CollectionRef colImages = PA_CreateCollection();
    
    image_format_t image_format = get_image_format(options);
    
    bool export_tags = ob_get_b(options, L"tags");
    
    if(export_tags)
    {
        colTags = PA_CreateCollection();
    }
    
    int images_count = (int)ob_get_n(options, L"count");/* default:-1 */
    
    if(h)
    {
        PA_long32 size = PA_GetHandleSize(h);
        
        imebra::ReadMemory mem((const char *)PA_LockHandle(h), size);
        imebra::MemoryStreamInput input(mem);
        imebra::StreamReader reader(input);
        
        std::unique_ptr<imebra::DataSet> data(imebra::CodecFactory::load(reader));

        /* get tags */
        if(export_tags)
        {
            imebra::tagsIds_t tags = data->getTags();
            for (imebra::tagsIds_t::iterator it = tags.begin() ; it != tags.end(); ++it)
            {
                imebra::TagId t = *it;
                
                //tag properties
                std::uint16_t tagId = t.getTagId();
                std::uint16_t groupId = t.getGroupId();
                std::uint32_t groupOrder = t.getGroupOrder();
                
                imebra::Tag *tag = data->getTag(t);
                imebra::tagVR_t dataType = tag->getDataType();
                std::wstring tagDataTypeName;
                tagDataTypeName += ((int)dataType >> 8);
                tagDataTypeName += ((int)dataType&0xFF);
                
                size_t bufferId = 0;
                while (data->bufferExists(t, bufferId))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_ObjectRef objTag = PA_CreateObject();
                    
                    ob_set_a(objTag, L"type", tagDataTypeName.c_str());
                    ob_set_a(objTag, L"value", data->getUnicodeString(t, bufferId, L"").c_str());
                    
                    ob_set_i(objTag, L"id", tagId);
                    ob_set_i(objTag, L"group", groupId);
                    ob_set_i(objTag, L"order", groupOrder);
                    ob_set_i(objTag, L"index", bufferId);
                    
                    PA_SetObjectVariable(&vObj, objTag);
                    PA_SetCollectionElement(colTags, PA_GetCollectionLength(colTags), vObj);
                    
                    PA_ClearVariable(&vObj);
                    
                    bufferId++;
                }
            }
        }

        /* get images */
        size_t page = 0;
        imebra::Image *image;

        do
        {
            if((images_count < 0) || (images_count > page))
            {
                image = NULL;
                try{
                    image = data->getImageApplyModalityTransform(page);
                }catch(...)
                {
                    break;
                }
                
                if(image)
                {
                    page++;
                    
                    std::string colorSpace = imebra::ColorTransformsFactory::normalizeColorSpace(image->getColorSpace());
                    std::uint32_t width = image->getWidth();
                    std::uint32_t height = image->getHeight();
                    
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_ObjectRef objImage = PA_CreateObject();
                    
                    ob_set_i(objImage, L"width", width);
                    ob_set_i(objImage, L"height", height);
                    ob_set_s(objImage, L"colorspace", colorSpace.c_str());
                    
                    std::unique_ptr<imebra::ReadingDataHandlerNumeric> dataHandler(image->getReadingDataHandler());
                    
                    /* retrive image */
                    imebra::TransformsChain chain;

                    size_t requestedBufferSize = 0;
                    bool gotBitmap = false;
                    
                    imebra::DrawBitmap draw(chain);
                    
                    if(imebra::ColorTransformsFactory::isMonochrome(image->getColorSpace()))
                    {
                        imebra::VOILUT voilutTransform;
                        imebra::vois_t vois = data->getVOIs();
                        std::list<std::shared_ptr<imebra::LUT> > luts;
                        for(size_t scanLUTs(0); ; ++scanLUTs)
                        {
                            try
                            {
                                luts.push_back((std::shared_ptr<imebra::LUT>)data->getLUT(imebra::TagId(imebra::tagId_t::VOILUTSequence_0028_3010), scanLUTs));
                            }
                            catch(...)
                            {
                                break;
                            }
                        }
                        if(!vois.empty())
                        {
                            voilutTransform.setCenterWidth(vois[0].center, vois[0].width);
                        }
                        else if(!luts.empty())
                        {
                            voilutTransform.setLUT(*(luts.front().get()));
                        }
                        else
                        {
                            voilutTransform.applyOptimalVOI(*image, 0, 0, width, height);
                        }
                        chain.addTransform(voilutTransform);
                        imebra::DrawBitmap draw(chain);
                        gotBitmap = true;
                        
                    }else
                    {
                        if(colorSpace != "RGB")
                        {
                            imebra::Transform *colorSpaceTransform = imebra::ColorTransformsFactory::getTransform(colorSpace, "RGB");
                            chain.addTransform(*colorSpaceTransform);
                            
                            gotBitmap = true;
                            
                        }
                    }
                    
                    std::vector<char> buffer;
                    
                    if(gotBitmap)
                    {
                        requestedBufferSize = draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, 0, 0);
                        buffer.resize(requestedBufferSize, char(0));
                        
                        try{
                            draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, (char *)&(buffer.at(0)), requestedBufferSize);
                        }catch(...)
                        {
                            gotBitmap = 0;
                        }
                    }
                    
                    if(gotBitmap)
                    {
                        bitmap_file_header bfh;
                        bitmap_image_header bih;
                        
                        int file_size = sizeof_bitmap_file_header + sizeof_bitmap_image_header + requestedBufferSize;
                        int offset_bits = sizeof_bitmap_file_header + sizeof_bitmap_image_header;
                        
                        memcpy(&bfh.bitmap_type, "BM", 2);
                        
                        bfh.file_size       = file_size;
                        bfh.reserved1       = 0;
                        bfh.reserved2       = 0;
                        bfh.offset_bits     = offset_bits;
                        
                        bih.size_header     = sizeof_bitmap_image_header;
                        bih.width           = width;
                        bih.height          = height;
                        bih.planes          = 1;
                        bih.bit_count       = 32;
                        bih.compression     = 0;
                        bih.image_size      = 0;
                        bih.ppm_x           = 0;
                        bih.ppm_y           = 0;
                        bih.clr_used        = 0;
                        bih.clr_important   = 0;
                        
                        std::vector<char> _buffer;
                        _buffer.resize(
                                       sizeof_bitmap_file_header
                                       +sizeof_bitmap_image_header
                                       +requestedBufferSize, char(0));
                        
                        memcpy(&(_buffer.at(0)), &bfh, sizeof_bitmap_file_header);
                        memcpy(&(_buffer.at(sizeof_bitmap_file_header)), &bih, sizeof_bitmap_image_header);
                        memcpy(&(_buffer.at(sizeof_bitmap_file_header+sizeof_bitmap_image_header)), &(buffer.at(0)), requestedBufferSize);
                        

                        switch (image_format) {
                            case image_format_png:
                            case image_format_jpg:
                            case image_format_gif:
                            case image_format_tiff:
                            case image_format_wbmp:
                            case image_format_webp:
                            {
                                gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                if(gd_in)
                                {
                                    get_image(gd_in, objImage, options);
                                    gdImageDestroy(gd_in);
                                }
                            }
                                break;
                            default:
                            {
                                if ((int)ob_get_n(options, L"quality") != 0)
                                {
                                    gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                    if(gd_in)
                                    {
                                        get_image(gd_in, objImage, options);
                                        gdImageDestroy(gd_in);
                                    }
                                }else
                                {
                                    PA_Picture picture = PA_CreatePicture((void *)&_buffer.at(0), _buffer.size());
                                    ob_set_p(objImage, L"image", picture);
                                    ob_set_a(objImage, L"format", L".bmp");
                                    ob_set_i(objImage, L"size", _buffer.size());
                                    ob_set_i(objImage, L"compression", 0);
                                }
                            }
                                break;
                        }
                        
                    }
                    
                    PA_SetObjectVariable(&vObj, objImage);
                    PA_SetCollectionElement(colImages, PA_GetCollectionLength(colImages), vObj);
                    PA_ClearVariable(&vObj);
                }

            }else{break;}

        }while(image);
        
        PA_UnlockHandle(h);
    }

    if(export_tags)
    {
       ob_set_c(returnValue, L"tags", colTags);
    }

    ob_set_c(returnValue, L"images", colImages);
    
    PA_ReturnObject( params, returnValue );
}

void Imebra_Apply_filters(PA_PluginParameters params){
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    PA_Handle h = PA_GetBlobHandleParameter( params, 1 );
    PA_ObjectRef options = PA_GetObjectParameter( params, 2 );

    PA_CollectionRef colImages = PA_CreateCollection();
    PA_CollectionRef colAppliedFilters = PA_CreateCollection();
    
    image_format_t image_format = get_image_format(options);

    if(h)
    {
        PA_long32 size = PA_GetHandleSize(h);
        void *p = PA_LockHandle(h);
        
        gdImagePtr gd_in = NULL;
        
        PA_Variable vObj0 = PA_CreateVariable(eVK_Object);
        PA_Variable vObj1 = PA_CreateVariable(eVK_Object);
        PA_ObjectRef objImage0 = PA_CreateObject();
        PA_ObjectRef objImage1 = PA_CreateObject();
        
        switch (image_format) {
            case image_format_png:
                gd_in = gdImageCreateFromPngPtr(size, p);
                break;
            case image_format_jpg:
                gd_in = gdImageCreateFromJpegPtr(size, p);
                break;
            case image_format_gif:
                gd_in = gdImageCreateFromGifPtr(size, p);
                break;
            case image_format_tiff:
                gd_in = gdImageCreateFromTiffPtr(size, p);
                break;
            case image_format_wbmp:
                gd_in = gdImageCreateFromWBMPPtr(size, p);
                break;
            case image_format_webp:
                gd_in = gdImageCreateFromWebpPtr(size, p);
                break;
            default:
                gd_in = gdImageCreateFromBmpPtr(size, p);
                break;
        }
        
        if(gd_in)
        {
            PA_CollectionRef colFilters = ob_get_c(options, L"filters");
            
            if(colFilters)
            {
                PA_long32 len = PA_GetCollectionLength(colFilters);
                
                if(len < 2)
                {
                    get_image(gd_in, objImage0, options);//return original image in #0
                    
                    if(len == 1)
                    {
                        apply_filter(&gd_in, colFilters, 0, colAppliedFilters);
                    }
                }else
                {
                    //more than 2 filters
                    for(PA_long32 i = 0; i < (len - 1); ++i)
                    {
                        apply_filter(&gd_in, colFilters, i, colAppliedFilters);
                    }
                    get_image(gd_in, objImage0, options);//return 1 before last filter in #0
                    
                    apply_filter(&gd_in, colFilters, len - 1, colAppliedFilters);
                }

                get_image(gd_in, objImage1, options);
                
                PA_SetObjectVariable(&vObj0, objImage0);
                PA_SetCollectionElement(colImages, 0, vObj0);
                PA_ClearVariable(&vObj0);
                
                PA_SetObjectVariable(&vObj1, objImage1);
                PA_SetCollectionElement(colImages, 1, vObj1);
                PA_ClearVariable(&vObj1);
                
            }
            gdImageDestroy(gd_in);
        }
        
        PA_UnlockHandle(h);
    }

    ob_set_c(returnValue, L"images", colImages);
    ob_set_c(returnValue, L"filters", colAppliedFilters);
    
    PA_ReturnObject( params, returnValue );
}

#pragma mark -

image_format_t get_image_format(PA_ObjectRef options){
    
    image_format_t image_format = image_format_bmp;
    
    CUTF8String format;
    if(ob_get_a(options, L"format", &format))
    {
        if(format == (const uint8_t *)".png"){
            image_format = image_format_png;
            goto get_image_format_exit;
        }
        if((format == (const uint8_t *)".jpeg")||(format == (const uint8_t *)".jpg")){
            image_format = image_format_jpg;
            goto get_image_format_exit;
        }
        
        if(format == (const uint8_t *)".gif"){
            image_format = image_format_gif;
            goto get_image_format_exit;
        }
        if(format == (const uint8_t *)".wbmp"){
            image_format = image_format_wbmp;
            goto get_image_format_exit;
        }
        
        if(format == (const uint8_t *)".webp"){
            image_format = image_format_webp;
            goto get_image_format_exit;
        }
        if((format == (const uint8_t *)".tiff")||(format == (const uint8_t *)".tif")){
            image_format = image_format_tiff;
            goto get_image_format_exit;
        }
    }
    
    get_image_format_exit :
    
    return image_format;
}

void apply_filter(gdImagePtr *gd, PA_CollectionRef colFilters, PA_long32 i, PA_CollectionRef colAppliedFilters){
    
    PA_Variable v = PA_GetCollectionElement(colFilters, i);
    if(PA_GetVariableKind(v)== eVK_Object)
    {
        PA_ObjectRef objFilter = PA_GetObjectVariable(v);

        CUTF8String filter;
        if(ob_get_a(objFilter, L"filter", &filter))
        {
            if(filter == (const uint8_t *)"selectiveBlur"){
                
                if(gdImageSelectiveBlur(*gd))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"edgeDetectQuick"){
                
                if(gdImageEdgeDetectQuick(*gd))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"emboss"){
                
                if(gdImageEmboss(*gd))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"meanRemoval"){
                
                if(gdImageMeanRemoval(*gd))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"grayScale"){
                
                if(gdImageGrayScale(*gd))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"negate"){
                
                if(gdImageNegate(*gd))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"smooth"){
                
                double weight = ob_get_n(objFilter, L"weight");
                if(gdImageSmooth(*gd, weight))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"brightness"){
                
                double brightness = ob_get_n(objFilter, L"brightness");
                if(gdImageBrightness(*gd, brightness))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"contrast"){
                
                double contrast = ob_get_n(objFilter, L"contrast");
                if(gdImageContrast(*gd, contrast))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"rotate"){
                
                int angle = ob_get_n(objFilter, L"angle");
                int dstW = ob_get_n(objFilter, L"dstW");/* dstW */
                int dstH = ob_get_n(objFilter, L"dstH");/* dstH */
                int dstX = ob_get_n(objFilter, L"dstX");/* dstX */
                int dstY = ob_get_n(objFilter, L"dstY");/* dstY */

                int srcW = ob_get_n(objFilter, L"srcW");/* srcW */
                int srcH = ob_get_n(objFilter, L"srcH");/* srcH */
                int srcX = ob_get_n(objFilter, L"srcX");/* srcX */
                int srcY = ob_get_n(objFilter, L"srcY");/* srcY */
                
                gdImagePtr _gd = gdImageCreateTrueColor(dstW, dstH);
                
                if(_gd)
                {
                    /* make background transparent */
                    gdImageAlphaBlending(_gd, 0);
                    gdImageFill(_gd, 0, 0, gdImageColorAllocateAlpha(_gd, 0, 0, 0, 255));
                    gdImageSaveAlpha(_gd, 1);
                    
                    gdImageCopyRotated(_gd, *gd,
                                       dstX,
                                       dstY,
                                       srcX,
                                       srcY,
                                       srcW, 
                                       srcH,
                                       angle);
                    
                    gdImageDestroy(*gd);
                    
                    *gd = _gd;
                    
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"scatter"){
                
                int sub = ob_get_n(objFilter, L"sub");
                int plus = ob_get_n(objFilter, L"plus");
                if(gdImageScatter(*gd, sub, plus))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"pixelate"){
                
                int block_size = ob_get_n(objFilter, L"size");
                int mode = ob_get_n(objFilter, L"mode");
                if(gdImagePixelate(*gd, block_size, mode))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"gaussianBlur"){
                
                int radius = ob_get_n(objFilter, L"radius");
                double sigma = ob_get_n(objFilter, L"sigma");
                
                gdImagePtr _gd = gdImageCopyGaussianBlurred(*gd, radius, sigma);

                if(_gd)
                {
                    gdImageDestroy(*gd);
                    
                    *gd = _gd;
                    
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"color"){
                
                int red = ob_get_n(objFilter, L"red");
                int green = ob_get_n(objFilter, L"green");
                int blue = ob_get_n(objFilter, L"blue");
                int alpha = ob_get_n(objFilter, L"alpha");
                
                if(gdImageColor(*gd, red, green, blue, alpha))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"scatterColor"){
                
                int sub = ob_get_n(objFilter, L"sub");
                int plus = ob_get_n(objFilter, L"plus");
                std::vector<int>colors;
                
                PA_CollectionRef _colors = ob_get_c(objFilter, L"colors");

                if(_colors)
                {
                    for(PA_long32 c = 0; c < PA_GetCollectionLength(_colors); ++c)
                    {
                        PA_Variable e = PA_GetCollectionElement(_colors, c);
                        if(PA_GetVariableKind(e) == eVK_Real)
                        {
                            colors.push_back((int)PA_GetRealVariable(e));
                        }
                    }
                }

                if(gdImageScatterColor(*gd, sub, plus, &colors[0], colors.size()))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
            if(filter == (const uint8_t *)"convolution"){
                
                double div = ob_get_n(objFilter, L"div");
                double offset = ob_get_n(objFilter, L"offset");

                float filter[3][3] = {
                    { 0.0, 0.0, 0.0},
                    { 0.0, 0.0, 0.0},
                    { 0.0, 0.0, 0.0}
                };
                
                PA_CollectionRef _filter = ob_get_c(objFilter, L"matrix");
                
                if(_filter)
                {
                    if(PA_GetCollectionLength(_filter) == 3)
                    {
                        for(PA_long32 y = 0; y < 3; ++y)
                        {
                            PA_Variable r = PA_GetCollectionElement(_filter, y);
                            if(PA_GetVariableKind(r) == eVK_Collection)
                            {
                                PA_CollectionRef c = PA_GetCollectionVariable(r);
                                if(PA_GetCollectionLength(c) == 3)
                                {
                                    for(PA_long32 x = 0; x < 3; ++x)
                                    {
                                        PA_Variable e = PA_GetCollectionElement(c, x);
                                        if(PA_GetVariableKind(e) == eVK_Real)
                                        {
                                            filter[y][x] = PA_GetRealVariable(e);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                if(gdImageConvolution(*gd, filter, div, offset))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&vObj, PA_DuplicateObject(objFilter));
                    PA_SetCollectionElement(colAppliedFilters, PA_GetCollectionLength(colAppliedFilters), vObj);
                    PA_ClearVariable(&vObj);
                }
                goto apply_filter_exit;
            }
        }
    }
    
    apply_filter_exit:
    
    PA_ClearVariable(&v);
}

void get_image(gdImagePtr gd, PA_ObjectRef objImage, PA_ObjectRef options){
    
    int jpeg_quality    =  0;
    int png_level       = -1;
    int wbmp_fg         = -1;
    int webp_quality    = -1;
    int bmp_compression =  0;
    
    if(ob_is_defined(options, L"quality"))
    {
        jpeg_quality = (int)ob_get_n(options, L"quality");
        //Compression quality: 0-95, 0=default
        
        webp_quality = jpeg_quality;
        //-1=default, 0-100        
    }

    if(ob_is_defined(options, L"compression"))
    {
        bmp_compression = (int)ob_get_n(options, L"compression") != 0;
        //whether to apply RLE or not
    }
    
    if(ob_is_defined(options, L"level"))
    {
        png_level = (int)ob_get_n(options, L"level");
        //compression level: 0=none, 1-9=level, -1=default
    }
    
    if(ob_is_defined(options, L"fg"))
    {
        wbmp_fg = (int)ob_get_n(options, L"fg");
    }
    
    image_format_t image_format = get_image_format(options);
    
    if(gd)
    {
        int len = 0;
        void *bytes = NULL;
        switch (image_format) {
            case image_format_png:
                bytes = gdImagePngPtrEx(gd, &len, png_level);
                if(bytes)
                {
                    PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                    ob_set_p(objImage, L"image", picture);
                    ob_set_a(objImage, L"format", L".png");
                    ob_set_i(objImage, L"size", len);
                    ob_set_i(objImage, L"level", png_level);
                    gdFree(bytes);
                }
                break;
            case image_format_jpg:
                bytes = gdImageJpegPtr(gd, &len, jpeg_quality);
                if(bytes)
                {
                    PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                    ob_set_p(objImage, L"image", picture);
                    ob_set_a(objImage, L"format", L".jpeg");
                    ob_set_i(objImage, L"size", len);
                    ob_set_i(objImage, L"quality", jpeg_quality);
                    gdFree(bytes);
                }
                break;
            case image_format_gif:
                bytes = gdImageGifPtr(gd, &len);
                if(bytes)
                {
                    PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                    ob_set_p(objImage, L"image", picture);
                    ob_set_a(objImage, L"format", L".gif");
                    ob_set_i(objImage, L"size", len);
                    gdFree(bytes);
                }
                break;
            case image_format_tiff:
                bytes = gdImageTiffPtr(gd, &len);
                if(bytes)
                {
                    PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                    ob_set_p(objImage, L"image", picture);
                    ob_set_a(objImage, L"format", L".tiff");
                    ob_set_i(objImage, L"size", len);
                    gdFree(bytes);
                }
                break;
            case image_format_wbmp:
                bytes = gdImageWBMPPtr(gd, &len, wbmp_fg);
                if(bytes)
                {
                    PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                    ob_set_p(objImage, L"image", picture);
                    ob_set_a(objImage, L"format", L".wbmp");
                    ob_set_i(objImage, L"size", len);
                    ob_set_i(objImage, L"fg", wbmp_fg);
                    gdFree(bytes);
                }
                break;
            case image_format_webp:
                bytes = gdImageWebpPtrEx(gd, &len, webp_quality);
                if(bytes)
                {
                    PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                    ob_set_p(objImage, L"image", picture);
                    ob_set_a(objImage, L"format", L".webp");
                    ob_set_i(objImage, L"size", len);
                    ob_set_i(objImage, L"quality", webp_quality);
                    gdFree(bytes);
                }
                break;
            default:
                bytes = gdImageBmpPtr(gd, &len, bmp_compression);
                if(bytes)
                {
                    PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                    ob_set_p(objImage, L"image", picture);
                    ob_set_a(objImage, L"format", L".bmp");
                    ob_set_i(objImage, L"size", len);
                    ob_set_i(objImage, L"compression", bmp_compression);
                    gdFree(bytes);
                }
                break;
        }
    }
}
