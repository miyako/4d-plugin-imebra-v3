/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Imebra
 #	author : miyako
 #	2016/12/06
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"


void PluginMain(PA_long32 selector, PA_PluginParameters params){
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

        switch(pProcNum)
        {
                // --- Imebra
                
            case 1 :
                Imebra_Get_images(params);
                break;
                
            default :
                CommandDispatcher(pProcNum, pResult, pParams);
                break;
        }

	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams){
	switch(pProcNum)
	{
// --- Imebra
	}
}

// ------------------------------------ Imebra ------------------------------------

void json_wconv(const wchar_t *value, CUTF16String *u16){
    size_t wlen = wcslen(value);
    
#if VERSIONWIN
    *u16 = CUTF16String((const PA_Unichar *)value, wlen);
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)value, wlen*sizeof(wchar_t), kCFStringEncodingUTF32LE, true);
    if(str)
    {
        int len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        *u16 = CUTF16String((const PA_Unichar *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

void ob_set_p(PA_ObjectRef obj, const wchar_t *_key, PA_Picture value){
    if(obj)
    {
        if(value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Picture);
            CUTF16String ukey;
            json_wconv(_key, &ukey);
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            
            PA_SetPictureVariable(&v, value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_s(PA_ObjectRef obj, const wchar_t *_key, const char *_value){
    if(obj)
    {
        if(_value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            CUTF16String ukey;
            
            json_wconv(_key, &ukey);
            
            CUTF8String u8 = CUTF8String((const uint8_t *)_value);
            C_TEXT t;t.setUTF8String(&u8);
            
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            PA_Unistring value = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
            
            PA_SetStringVariable(&v, &value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_a(PA_ObjectRef obj, const wchar_t *_key, const wchar_t *_value){
    if(obj)
    {
        if(_value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            CUTF16String ukey;
            CUTF16String uvalue;
            json_wconv(_key, &ukey);
            json_wconv(_value, &uvalue);
            
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            PA_Unistring value = PA_CreateUnistring((PA_Unichar *)uvalue.c_str());
            
            PA_SetStringVariable(&v, &value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_c(PA_ObjectRef obj, const wchar_t *_key, PA_CollectionRef value){
    if(obj)
    {
        if(value)
        {
            PA_Variable v = PA_CreateVariable(eVK_Collection);
            CUTF16String ukey;
            json_wconv(_key, &ukey);
            PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
            
            PA_SetCollectionVariable(&v, value);
            PA_SetObjectProperty(obj, &key, v);
            
            PA_DisposeUnistring(&key);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_i(PA_ObjectRef obj, const wchar_t *_key, PA_long32 value){
    if(obj)
    {
        PA_Variable v = PA_CreateVariable(eVK_Longint);
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        PA_SetLongintVariable(&v, value);
        PA_SetObjectProperty(obj, &key, v);
        
        PA_DisposeUnistring(&key);
        PA_ClearVariable(&v);
    }
}

void ob_set_b(PA_ObjectRef obj, const wchar_t *_key, bool value){
    if(obj)
    {
        PA_Variable v = PA_CreateVariable(eVK_Boolean);
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        PA_SetBooleanVariable(&v, value);
        PA_SetObjectProperty(obj, &key, v);
        
        PA_DisposeUnistring(&key);
        PA_ClearVariable(&v);
    }
}

bool ob_is_defined(PA_ObjectRef obj, const wchar_t *_key){
    bool is_defined = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        is_defined = PA_HasObjectProperty(obj, &key);
        
        PA_DisposeUnistring(&key);
    }
    return is_defined;
}

bool ob_get_a(PA_ObjectRef obj, const wchar_t *_key, CUTF8String *value){
    bool is_defined = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        is_defined = PA_HasObjectProperty(obj, &key);
        
        if(is_defined)
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Unistring)
            {
                PA_Unistring uvalue = PA_GetStringVariable(v);
                C_TEXT t;
                t.setUTF16String(&uvalue);
                t.copyUTF8String(value);
            }
        }

        PA_DisposeUnistring(&key);
    }
    
    return is_defined;
}

bool ob_get_b(PA_ObjectRef obj, const wchar_t *_key){
    bool value = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        if(PA_HasObjectProperty(obj, &key))
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Boolean)
            {
                value = PA_GetBooleanVariable(v);
            }
        }
        
        PA_DisposeUnistring(&key);
    }
    
    return value;
}

double ob_get_n(PA_ObjectRef obj, const wchar_t *_key){
    double value = -1;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        if(PA_HasObjectProperty(obj, &key))
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Real)
            {
                value = PA_GetRealVariable(v);
            }
        }
        
        PA_DisposeUnistring(&key);
    }
    
    return value;
}

void Imebra_Get_images(PA_PluginParameters params)
{
    PA_ObjectRef returnValue = PA_CreateObject();
    
    PA_Handle h = PA_GetBlobHandleParameter( params, 1 );
    PA_ObjectRef options = PA_GetObjectParameter( params, 2 );
    
    PA_CollectionRef colTags = PA_CreateCollection();
    PA_CollectionRef colImages = PA_CreateCollection();
    
    image_formats image_format = image_format_bmp;
    
    int jpeg_quality = (int)ob_get_n(options, L"quality");
    //Compression quality: 0-95, 0=default

    int png_level = jpeg_quality;
    //compression level: 0=none, 1-9=level, -1=default
    
    int wbmp_fg = (int)ob_get_n(options, L"fg");
    
    int webp_quality = jpeg_quality;
    //-1=default, 0-100
    
    CUTF8String format;
    if(ob_get_a(options, L"format", &format))
    {
        if(format == (const uint8_t *)".png"){
            image_format = image_format_png;
        }else
            if((format == (const uint8_t *)".jpeg")||(format == (const uint8_t *)".jpg")){
                image_format = image_format_jpg;
            }else
                if(format == (const uint8_t *)".gif"){
                    image_format = image_format_gif;
                }else
                    if(format == (const uint8_t *)".wbmp"){
                        image_format = image_format_wbmp;
                    }
                    else
                        if(format == (const uint8_t *)".webp"){
                            image_format = image_format_webp;
                        }else
                            if((format == (const uint8_t *)".tiff")||(format == (const uint8_t *)".tif")){
                                image_format = image_format_tiff;
                            }
    }
    
    bool export_tags = ob_get_b(options, L"tags");
    
    int images_count = (int)ob_get_n(options, L"count");
    
    if(h)
    {
        PA_long32 size = PA_GetHandleSize(h);
        
        imebra::ReadMemory mem((const char *)PA_LockHandle(h), size);
        imebra::MemoryStreamInput input(mem);
        imebra::StreamReader reader(input);
        
        std::unique_ptr<imebra::DataSet> data(imebra::CodecFactory::load(reader));

        /* get tags */
        if(export_tags)
        {
            imebra::tagsIds_t tags = data->getTags();
            for (imebra::tagsIds_t::iterator it = tags.begin() ; it != tags.end(); ++it)
            {
                imebra::TagId t = *it;
                
                //tag properties
                std::uint16_t tagId = t.getTagId();
                std::uint16_t groupId = t.getGroupId();
                std::uint32_t groupOrder = t.getGroupOrder();
                
                imebra::Tag *tag = data->getTag(t);
                imebra::tagVR_t dataType = tag->getDataType();
                std::wstring tagDataTypeName;
                tagDataTypeName += ((int)dataType >> 8);
                tagDataTypeName += ((int)dataType&0xFF);
                
                size_t bufferId = 0;
                while (data->bufferExists(t, bufferId))
                {
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_ObjectRef objTag = PA_CreateObject();
                    
                    ob_set_a(objTag, L"type", tagDataTypeName.c_str());
                    ob_set_a(objTag, L"value", data->getUnicodeString(t, bufferId, L"").c_str());
                    
                    ob_set_i(objTag, L"id", tagId);
                    ob_set_i(objTag, L"group", groupId);
                    ob_set_i(objTag, L"order", groupOrder);
                    ob_set_i(objTag, L"index", bufferId);
                    
                    PA_SetObjectVariable(&vObj, objTag);
                    PA_SetCollectionElement(colTags, PA_GetCollectionLength(colTags), vObj);
                    
                    PA_ClearVariable(&vObj);
                    
                    bufferId++;
                }
            }
        }

        /* get images */
        size_t page = 0;
        imebra::Image *image;

        do
        {
            if((images_count < 0) || (images_count > page))
            {
                image = NULL;
                try{
                    image = data->getImageApplyModalityTransform(page);
                }catch(...)
                {
                    break;
                }
                
                if(image)
                {
                    page++;
                    
                    std::string colorSpace = imebra::ColorTransformsFactory::normalizeColorSpace(image->getColorSpace());
                    std::uint32_t width = image->getWidth();
                    std::uint32_t height = image->getHeight();
                    
                    PA_Variable vObj = PA_CreateVariable(eVK_Object);
                    PA_ObjectRef objImage = PA_CreateObject();
                    
                    ob_set_i(objImage, L"width", width);
                    ob_set_i(objImage, L"height", height);
                    ob_set_s(objImage, L"colorspace", colorSpace.c_str());
                    
                    std::unique_ptr<imebra::ReadingDataHandlerNumeric> dataHandler(image->getReadingDataHandler());
                    
                    /* retrive image */
                    imebra::TransformsChain chain;

                    size_t requestedBufferSize = 0;
                    bool gotBitmap = false;
                    
                    imebra::DrawBitmap draw(chain);
                    
                    if(imebra::ColorTransformsFactory::isMonochrome(image->getColorSpace()))
                    {
                        imebra::VOILUT voilutTransform;
                        imebra::vois_t vois = data->getVOIs();
                        std::list<std::shared_ptr<imebra::LUT> > luts;
                        for(size_t scanLUTs(0); ; ++scanLUTs)
                        {
                            try
                            {
                                luts.push_back((std::shared_ptr<imebra::LUT>)data->getLUT(imebra::TagId(imebra::tagId_t::VOILUTSequence_0028_3010), scanLUTs));
                            }
                            catch(...)
                            {
                                break;
                            }
                        }
                        if(!vois.empty())
                        {
                            voilutTransform.setCenterWidth(vois[0].center, vois[0].width);
                        }
                        else if(!luts.empty())
                        {
                            voilutTransform.setLUT(*(luts.front().get()));
                        }
                        else
                        {
                            voilutTransform.applyOptimalVOI(*image, 0, 0, width, height);
                        }
                        chain.addTransform(voilutTransform);
                        imebra::DrawBitmap draw(chain);
                        gotBitmap = true;
                        
                    }else
                    {
                        if(colorSpace != "RGB")
                        {
                            imebra::Transform *colorSpaceTransform = imebra::ColorTransformsFactory::getTransform(colorSpace, "RGB");
                            chain.addTransform(*colorSpaceTransform);
                            
                            gotBitmap = true;
                            
                        }
                    }
                    
                    std::vector<char> buffer;
                    
                    if(gotBitmap)
                    {
                        requestedBufferSize = draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, 0, 0);
                        buffer.resize(requestedBufferSize, char(0));
                        
                        try{
                            draw.getBitmap(*image, imebra::drawBitmapType_t::drawBitmapRGBA, 4, (char *)&(buffer.at(0)), requestedBufferSize);
                        }catch(...)
                        {
                            gotBitmap = 0;
                        }
                    }
                    
                    if(gotBitmap)
                    {
                        bitmap_file_header bfh;
                        bitmap_image_header bih;
                        
                        int file_size = sizeof_bitmap_file_header + sizeof_bitmap_image_header + requestedBufferSize;
                        int offset_bits = sizeof_bitmap_file_header + sizeof_bitmap_image_header;
                        
                        memcpy(&bfh.bitmap_type, "BM", 2);
                        
                        bfh.file_size       = file_size;
                        bfh.reserved1       = 0;
                        bfh.reserved2       = 0;
                        bfh.offset_bits     = offset_bits;
                        
                        bih.size_header     = sizeof_bitmap_image_header;
                        bih.width           = width;
                        bih.height          = height;
                        bih.planes          = 1;
                        bih.bit_count       = 32;
                        bih.compression     = 0;
                        bih.image_size      = 0;
                        bih.ppm_x           = 0;
                        bih.ppm_y           = 0;
                        bih.clr_used        = 0;
                        bih.clr_important   = 0;
                        
                        std::vector<char> _buffer;
                        _buffer.resize(
                                       sizeof_bitmap_file_header
                                       +sizeof_bitmap_image_header
                                       +requestedBufferSize, char(0));
                        
                        memcpy(&(_buffer.at(0)), &bfh, sizeof_bitmap_file_header);
                        memcpy(&(_buffer.at(sizeof_bitmap_file_header)), &bih, sizeof_bitmap_image_header);
                        memcpy(&(_buffer.at(sizeof_bitmap_file_header+sizeof_bitmap_image_header)), &(buffer.at(0)), requestedBufferSize);
                        
                        int len = 0;
                        void *bytes = NULL;
                        
                        switch (image_format) {
                            case image_format_png:
                            {
                                gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                if(gd_in)
                                {
                                    bytes = gdImagePngPtrEx(gd_in, &len, png_level);
                                    if(bytes)
                                    {
                                        PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                                        ob_set_p(objImage, L"image", picture);
                                        ob_set_a(objImage, L"format", L".png");
                                        ob_set_i(objImage, L"size", len);
                                        ob_set_i(objImage, L"level", png_level);
                                        gdFree(bytes);
                                    }
                                }
                            }
                                break;
                            case image_format_jpg:
                            {
                                gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                if(gd_in)
                                {
                                    bytes = gdImageJpegPtr(gd_in, &len, jpeg_quality);
                                    if(bytes)
                                    {
                                        PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                                        ob_set_p(objImage, L"image", picture);
                                        ob_set_a(objImage, L"format", L".jpeg");
                                        ob_set_i(objImage, L"size", len);
                                        ob_set_i(objImage, L"quality", jpeg_quality);
                                        gdFree(bytes);
                                    }
                                }
                            }
                                break;
                            case image_format_gif:
                            {
                                gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                if(gd_in)
                                {
                                    bytes = gdImageGifPtr(gd_in, &len);
                                    if(bytes)
                                    {
                                        PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                                        ob_set_p(objImage, L"image", picture);
                                        ob_set_a(objImage, L"format", L".gif");
                                        ob_set_i(objImage, L"size", len);
                                        gdFree(bytes);
                                    }
                                }
                            }
                                break;
                            case image_format_tiff:
                            {
                                gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                if(gd_in)
                                {
                                    bytes = gdImageTiffPtr(gd_in, &len);
                                    if(bytes)
                                    {
                                        PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                                        ob_set_p(objImage, L"image", picture);
                                        ob_set_a(objImage, L"format", L".tiff");
                                        ob_set_i(objImage, L"size", len);
                                        gdFree(bytes);
                                    }
                                }
                            }
                                break;
                            case image_format_wbmp:
                            {
                                gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                if(gd_in)
                                {
                                    bytes = gdImageWBMPPtr(gd_in, &len, wbmp_fg);
                                    if(bytes)
                                    {
                                        PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                                        ob_set_p(objImage, L"image", picture);
                                        ob_set_a(objImage, L"format", L".wbmp");
                                        ob_set_i(objImage, L"size", len);
                                        ob_set_i(objImage, L"fg", wbmp_fg);
                                        gdFree(bytes);
                                    }
                                }
                            }
                                break;
                            case image_format_webp:
                            {
                                gdImagePtr gd_in = gdImageCreateFromBmpPtr(_buffer.size(), (void *)&_buffer.at(0));
                                if(gd_in)
                                {
                                    bytes = gdImageWebpPtrEx(gd_in, &len, webp_quality);
                                    if(bytes)
                                    {
                                        PA_Picture picture = PA_CreatePicture((void *)bytes, len);
                                        ob_set_p(objImage, L"image", picture);
                                        ob_set_a(objImage, L"format", L".webp");
                                        ob_set_i(objImage, L"size", len);
                                        ob_set_i(objImage, L"quality", webp_quality);
                                        gdFree(bytes);
                                    }
                                }
                            }
                                break;
                            default:
                            {
                                PA_Picture picture = PA_CreatePicture((void *)&_buffer.at(0), _buffer.size());
                                ob_set_p(objImage, L"image", picture);
                                ob_set_a(objImage, L"format", L".bmp");
                                ob_set_i(objImage, L"size", _buffer.size());
                            }
                                break;
                        }
                        
                    }
                    
                    PA_SetObjectVariable(&vObj, objImage);
                    PA_SetCollectionElement(colImages, PA_GetCollectionLength(colImages), vObj);
                    PA_ClearVariable(&vObj);
                }

            }else{break;}

        }while(image);
        
        PA_UnlockHandle(h);
    }

    if(export_tags)
    {
       ob_set_c(returnValue, L"tags", colTags);
    }

    ob_set_c(returnValue, L"images", colImages);
    
    PA_ReturnObject( params, returnValue );
}
